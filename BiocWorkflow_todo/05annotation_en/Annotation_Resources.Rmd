---
title: Genomic Annotation Resources
author:
- name: Marc RJ Carlson
  affiliation: Fred Hutchinson Cancer Research Center, 1100 Fairview Ave. N., P.O. Box 19024, Seattle, WA, USA 98109-1024
- name: Herve Pages
  affiliation: Fred Hutchinson Cancer Research Center, 1100 Fairview Ave. N., P.O. Box 19024, Seattle, WA, USA 98109-1024
- name: Sonali Arora
  affiliation: Fred Hutchinson Cancer Research Center, 1100 Fairview Ave. N., P.O. Box 19024, Seattle, WA, USA 98109-1024
- name: Valerie Obenchain
  affiliation: Fred Hutchinson Cancer Research Center, 1100 Fairview Ave. N., P.O. Box 19024, Seattle, WA, USA 98109-1024
- name: Martin Morgan
  affiliation: Fred Hutchinson Cancer Research Center, 1100 Fairview Ave. N., P.O. Box 19024, Seattle, WA, USA 98109-1024
  email: maintainer@bioconductor.org
output:
  BiocStyle::html_document
date: 24 April 2018
KeyWords: annotation, next-generation sequencing, R, Bioconductor
vignette: >
  %\VignetteIndexEntry{Genomic Annotation Resources}
  %\VignetteEngine{knitr::rmarkdown}
---

# 版本信息
```{r, echo=FALSE, results="hide", warning=FALSE}
suppressPackageStartupMessages({
library('annotation')
})
```
<p>
**R 版本**: `r R.version.string`
<br />
**Bioconductor 版本**: `r BiocManager::version()`
<br />
**Package 版本**: `r packageVersion("annotation")`
</p>

# 简介

注释资源在 Bioconductor 的项目中占很大比例【1】。
此外，还可使用特定的包来获取一些允许访问的在线资源。
这里将介绍使用得比较多的资源，并提供一些关于如何使用它们的高级示例。



在过去，一般在分析结束时使用 Bioconductor 注释资源进行注释。
进行大量的数据分析之后，都会使用注释信息来解析最重要的分析结果。
由于注释信息使用得越来越多，在分析起始或是中间某个步骤也会应用它们，
从而帮助指导仍在进行中的研究。除此之外，注释的含义也变得不像以前那么明确。  
习惯上认为，注释只是在进行了多次不同的研究（如基因产物的主要作用）之后才建立起来的东西。
但如今，社区用与以往经典注释几近相同的注释方式来解析大型数据集，即将之作为附加比较的参考。 






 Bioconductor 中的注释资源的获取方式也发生了变化。
以往的注释资源几乎都是以独立的注释包的形式存在【2,3,4】。
而在今天，注释包含有大量注释资源。
目前存储库[release repository](http://bioconductor.org/packages/release/BiocViews.html#___AnnotationData)
有 800 多个的注释包。 下表总结了经常使用包访问的部分重要的注释对象的类：




<style>
table, th, td {
    border-collapse: collapse;
}
th, td {
    padding: 5px;
}
th {
    text-align: left;
    background-color: #D0D0D0;
}
</style>

<table width="100%">
  <tr>
    <th> Object Type </th>
    <th> Example Package Name </th>
    <th> Contents </th>
  </tr>
  <tbody>
    <tr>
      <td> TxDb </td>
      <td>
        <a href =
          "http://bioconductor.org/packages/TxDb.Hsapiens.UCSC.hg19.knownGene/">
          <div> TxDb.Hsapiens.UCSC.hg19.knownGene </div>
        </a>
      </td>
      <td> Transcriptome ranges for the known gene track of Homo sapiens,
           e.g., introns, exons, UTR regions. </td>
    </tr>
    <tr>
      <td> OrgDb </td>
      <td>
        <a href = "http://bioconductor.org/packages/org.Hs.eg.db/">
        <div> org.Hs.eg.db </div>
        </a>
      </td>
      <td> Gene-based information for Homo sapiens; useful for mapping between
           gene IDs, Names, Symbols, GO and KEGG identifiers, etc. </td>
    </tr>
    <tr>
      <td> BSgenome </td>
      <td>
        <a href =
        "http://bioconductor.org/packages/BSgenome.Hsapiens.UCSC.hg19/">
        <div> BSgenome.Hsapiens.UCSC.hg19 </div>
        </a>
      </td>
      <td> Full genome sequence for Homo sapiens. </td>
    </tr>
    <tr>
      <td> Organism.dplyr </td>
      <td>
        <a href = "http://bioconductor.org/packages/Organism.dplyr/">
        <div> src_organism </div>
        </a>
      </td>
      <td> Collection of multiple annotations for a common organism
           and genome build. </td>
    </tr>
    <tr>
      <td> AnnotationHub </td>
      <td>
        <a href = "http://bioconductor.org/packages/AnnotationHub/">
        <div> AnnotationHub </div>
        </a>
      </td>
      <td> Provides a convenient interface to annotations from many
           different sources; objects are returned as fully parsed Bioconductor
           data objects or as the name of a file on disk. </td>
    </tr>
  </tbody>
</table>

尽管注释包很受欢迎，但是提供 Web 服务（如 **biomaRt**【5,6,7】 ）的包和 **AnnotationHub**【8】
包仍然撤下了越来越多的注释资源。这两种包都含有大量的注释资源。



由于快速发展，目前很难发现 Bioconductor 的单个文档包含有所有可能的注释，甚至每种注释。
因此，在这里我们将在一定程度上介绍并描述最流行的注释资源，旨在公开访问它们的常见模式。
希望拥有此信息的用户能够对如何查找和使用必需的附加资源进行有根据的猜测。 
主题将涵盖以下内容：






# 安装

本章我们会用到部分 Bioconductor 包。 您可以使用 `BiocManager::install()` 进行安装： 


```{r, eval=FALSE}
if (!"BiocManager" %in% rownames(installed.packages()))
     install.packages("BiocManager")
BiocManager::install(c("AnnotationHub", "Homo.sapiens",
           "Organism.dplyr",
           "TxDb.Hsapiens.UCSC.hg19.knownGene",
           "TxDb.Hsapiens.UCSC.hg38.knownGene",
           "BSgenome.Hsapiens.UCSC.hg19", "biomaRt",
           "TxDb.Athaliana.BioMart.plantsmart22"))
```
已安装包的使用方法将会在使用部分进行详细阐述。



# 使用 AnnotationHub

在注释资源列表中靠前的是相对较新的 **AnnotationHub** 包【8】。
创建 AnnotationHub 对象是为了给最终用户提供一个通过 Bioconductor 能够查找大量不同注释对象的便捷接入点。
在 **AnnotationHub** 包中很容易找到注释资源并且以熟悉的 Bioconductor 数据对象形式呈现给用户。
由于它是最近才增加，因此 **AnnotationHub** 允许访问各种形式的注释（如对象），其中一些注释在几年前还不被视为注释。
用户开始使用 AnnotationHub ，只需要加载包，然后创建一个本地 AnnotationHub 对象，如下所示：






```{r, echo=FALSE}
library(annotation)
ah <- AnnotationHub()
```

```{r, eval=FALSE}
ah <- AnnotationHub()
```

第一次调用 AnnotationHub() 时，它将在系统里创建一个缓存目录，并下载 hubs 当前内容的最新元数据。
此时， 当您下载 hubs 数据对象时，它们也会缓存在本地目录中，然后当您再次请求信息的时候，
这些数据文件能被快速访问。



AnnotationHub 对象的结果显示了您当前可以使用该对象访问的资源数量，
并同时给出最常见的数据类型的高级概述。


```{r}
ah
```

正如您从上述对象中所看到的，有很多不同的可用资源。
因此，通常当您获得 AnnotationHub 对象之后首先要做的就是进行筛选，
从而删除不需要的资源。

幸运的是， AnnotationHub 具有几种用于搜索和筛选的不同类型的元数据。 
键入您的 AnnotationHub 对象的名称，然后通过 「$」 运算符补全命令可以查看对象中不同的类别。
要查看单一类别中的所有可能内容，可以将该值传递给 unique() ，如下所示:



```{r}
unique(ah$dataprovider)
```

标记数据的最有意义的方法之一是根据能够返回给您的R对象类型来标记数据。


```{r}
unique(ah$rdataclass)
```

确定要用于查找感兴趣的数据的哪些类型元数据后,
可以使用子集或查询方法将中心对象的大小减小到更易于管理的大小。
一旦您已经确定用哪些类型的元数据来查找您所感兴趣的数据，
您就能用 subset() 或者 query() 方法缩减 hub 对象的大小，以便于更好的管理对象。
比如说，您选择元数据中只有字符串 「GRanges」 所在的记录。
如您之前所看到的， GRanges 是 AnnotationHub 对象中最流行的格式之一。

```{r}
grs <- query(ah, "GRanges")
grs
```

或者您可以使用提取子集的方式，仅选择特定字段上的匹配项

```{r}
grs <- ah[ah$rdataclass == "GRanges",]

```
 subset() 函数也有这种筛选功能。

```{r}
orgs <- subset(ah, ah$rdataclass == "OrgDb")
orgs
```

实际上如果您需要访问所有元数据，则可以用 mcols() 将其提取为 DataFrame 格式的数据对象，如下所示:


```{r}
meta <- mcols(ah)
```

此外，如果您是 GUI （图形用户界面）的粉丝，则可以使用 dispaly() 方法在浏览器中查看数据，
并将所选行返回为较小的 AnnotationHub 对象，如下所示：


```{r, eval=FALSE}
sah <- display(ah)
```

调用此方法将生成基于 Web 的界面，如下图所示:


<img src="display.png" width="100%">


一旦将 AnnotationHub 对象缩减到合理的大小，并确定要检索哪些字段，
那您只需使用 「[[」 运算符来提取它们。
使用 「[[」 运算符，您就可以按数字索引 (1,2,3) 或 AnnotationHub ID 进行提取。 
如果选择使用前者，只需提取您感兴趣的元素即可。 因此，对于我们的一系列范例，您可能只想用第一个索引，如下所示: 



```{r}
res <- grs[[1]]
head(res, n=3)
```

## AnnotationHub 练习

练习 1: 使用 AnnotationHub 来提取 UCSC 数据库中人的 hg19 基因组数据。在筛选每一步的数据时，
 hub 对象会发生什么情况？


练习 2: 您现在基本上已经将内容缩小到 UCSC 基因组浏览器的 hg19 基因组注释，
让我们获取这些注释之一。查找 oreganno 字段并将其保存到局部变量中。


<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>


# OrgDb 对象

此时您可能有个疑问： OrgDb 对象是关于什么的？ 
OrgDb 对象是注释对象系列中的一个成员，
所有注释对象都通过一组共享的方法表示所隐藏的数据。 
因此，如果您仔细看看下面创建的 dog 对象, 您可以看到它包含 Canis familiaris 数据( taxonomy ID = 9615)。
通过 columns() 函数，您可以更多地了解 dog 对象。


```{r}
dog <- query(orgs, "Canis familiaris")[[1]]
dog
```

```{r}
columns(dog)
```

columns() 函数允许从该对象中调用能检索到的数据类型矢量。 
因此，上述调用结果表示可以从 tetra 对象检索多种不同的数据类型。
 

一个类似的函数是 keytype() ，它将列出所有也可以用作关键词的数据类型。


```{r}
keytypes(dog)
```

大多数情况下，结果列出的大部分内容也能通过 keytypes() 调用返回，
但是由于这两个函数功能并不能保证完全相同，所以我们仍然单独使用这两个方法。


这时您能看到哪些类型的对象可用为关键词，可以调用 keys() 函数来提取给定关键词类型的所有关键词。


```{r}
head(keys(dog, keytype="ENTREZID"))
```

keys() 函数中额外的一些参数对获得特定类型的所有 ID 非常有用。
例如，使用 keys() ，您还可以像这样提取含有 「COX」 的基因符号:



```{r}
keys(dog, keytype="SYMBOL", pattern="COX")
```

或者，如果您确实需要其他的关键词类型（ keytype ），可以使用函数中 column 参数
提取包含字符串 「COX」 的基因符号的 ENTREZ 基因 ID:


```{r}
keys(dog, keytype="ENTREZID", pattern="COX", column="SYMBOL")
```

但通常来说，您会想要提取与特定关键词或一组关键词匹配的其他数据。
这里有两种方法可供您选择使用。其中功能更强大的可能是 select() 。
下面是如何通过查找基因符号，以及 REFSEQ ID 来查找特定的 entrez 基因 ID。


```{r}
select(dog, keys="804478", columns=c("SYMBOL","REFSEQ"), keytype="ENTREZID")
```

调用 select() 将返回一个 data.frame ，该数据框尝试为所需要的列填充相匹配的值。
但是，如果您用 select() 提取具有多对一关系的关键词内容，则可能会导致返回数据对象的扩展内容。
看看当我们为相同的 entrez 基因 ID 提取 GO 术语时会发生什么:



```{r}
select(dog, keys="804478", columns="GO", keytype="ENTREZID")
```

因为有多个 GO 术语与基因 「804478」 相关联，所以在 data.frame 中会有很多行。
如果您查找的几个列与原始关键词具有多对一关系，那么可能会出现问题。
这样做的话，结果不仅会成倍增长，而且会变得非常难用。
更好的策略是在调用 select() 时使用具有选择性的关键词。




有时，您可能想以一种比 select() 返回 data.frame 对象更简单的方式来查找匹配结果。
当您只想为每个关键词查找一种值时，这一点尤其重要。
对于这些情况，我们建议您查看 mapIds() 函数。
让我们看看，使用 mapIds() 来查找与最近 select() 调用结果相同的基本信息时会发生什么情况： 


```{r}
mapIds(dog, keys="804478", column="GO", keytype="ENTREZID")
```

如您所见， mapIds() 允许您简化返回的结果。
默认情况下， mapIds() 只返回每个关键词的第一个匹配元素。
但如果您真的需要调用 mapIds() 时返回所有 GO 术语呢?
那么你可以利用 mapIds() 的 multiVals 参数。
这个参数有多个选项，我们已经看到默认情况下只能返回 「first」 结果。
但你也可以返回一个 「list」 或 「CharacterList」 对象，
或者你可以用 「filter」 筛选或返回 「asNA」 有多个匹配的任何关键词。
您甚至可以自定义规则（作为函数），并将其作为参数传递给 multiVals 参数。
让我们看看返回一个列表时会发生什么:


```{r}
mapIds(dog, keys="804478", column="GO", keytype="ENTREZID", multiVals="list")
```

现在，您知道了如何从 OrgDb 对象中提取信息，
您可能会发现，如果知道一系列其他 AnnotationDb 派生的对象，
使用这五种方法（ keytypes()、 columns()、 keys()、 select() 和 mapIds()）也是非常有帮助的。
例如， ChipDb 对象、 InparanoidDb 对象和 TxDb 对象分别包含微阵列探针、inparanoid 同源信息或转录范围信息的数据。
当然还有更专一的对象，比如 GODb 或 ReactomeDb 对象，
它们提供访问 GO 和 reactome 数据库的权限。
在下一节中，我们将看到这些对象中比较流行的 TxDb 对象。




## OrgDb 练习

练习 3: 使用 help("SYMBOL") 查看帮助页面中不同的 columns 和 keytypes 参数值。
现在利用这个信息和我们刚才描述的来查找基因符号 「MSX2」 的 entrez 基因和其染色体。


练习 4: 在之前的练习中，我们使用基因符号作为关键词。
但在过去，这种取值行为有时是不可取的，因为一些基因符号被用作多个基因的官方符号。
要了解这种情况是否仍然存在，利用 entrez 基因 ID 是唯一分配的这一事实，
并从 org.Hs.eg.db 包中提取所有的基因符号及其相关的 entrez 基因 ID 。
然后检查符号是否冗余。



<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>


# TxDb 对象

如前所述， TxDb 对象可以使用一系列标准方法进行访问:
keytypes()， columns()， keys()， select() 和 mapIds()。
但是，由于这些对象包含有关转录组的信息，它们通常用于比较基于转录组信息的范围和基因组的重要特征【3,4】。
因此，它们也有特地用来提取与重要的转录组特征相对应的范围的专用访问器。



让我们从基于 UCSC ensembl 基因记录果蝇的注释包中加载 TxDb 对象开始。
加载这些文件时的一个常见做法是将长名称缩短为 「txdb」 （只是为了方便）。


```{r}
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
txdb
```

仅通过查看 TxDb 对象，我们就可以了解它包含哪些数据，
数据来自何处，它基于 UCSC 基因组的哪个部分构建的，
以及对象最后一次更新的时间。
 TxDb 对象的常见用途之一是从中提取各种文本数据。
例如，您可以从 TxDb 中提取所有的转录本作为 GRanges 对象，就像这样:


```{r}
txs <- transcripts(txdb)
txs
```

同样，也存在 exons()， cds()， genes() 和 promoters() 等用于提取相关信息的函数。
您选择提取哪一种特性取决于您之后想要获取的信息。
如果您只想要这些数据的文本表示，那么这些基本提取函数都可以使用，
但是本质上来说，这些文本的特性大多是嵌套的。因此，与其提取一个简单的 GRanges 对象，
不如选择提取一个 GRangesList 对象，该对象根据与之相关的基因对转录本进行分组，如下图所示:



```{r}
txby <- transcriptsBy(txdb, by="gene")
txby
```

就像使用文本提取函数一样，还有一系列其他用于不同内容和分组方式的提取函数。
它们包括 transcriptsBy()、exonsBy()、cdsBy()、intronsByTranscript()、
fiveUTRsByTranscript() 和 threeUTRsByTranscript()。


在处理基因组数据时，难免会遇到不同群体采用不同的染色体命名方法的问题。
这是因为几乎每个主要存储库的标记这些重要特性的方法不同。



为了解决这个问题，创建了 Seqinfo 对象，
并将其加入到 TxDb 对象以及从这些对象中提取的 GenomicRanges 中。
您可以使用 seqinfo() 来进行提取，如下所示:

```{r}
si <- seqinfo(txdb)
si
```

由于 seqinfo 信息也附加到了 TxDb 提取函数生成的 GRanges 对象上，
所以您也能对这些函数的结果调用 seqinfo() ，如下所示:


```{r}
txby <- transcriptsBy(txdb, by="gene")
si <- seqinfo(txby)
```

 Seqinfo 对象包含许多有价值的数据，
关于其染色体特征的存在，它们是圆形的还是线性的，以及每个染色体的长度。
如果你想做一个像 「findOverlaps」 这样的操作来计算重叠范围等，你也需要检查 Seqinfo 对象。
因此，这是一种有价值的方法，可确保染色体和基因组对您的注释来说与您所比较的范围相同。
但是有时您可能会遇到这样的情况，注释对象包含与数据对象类似的数据，
但是它只是使用不同的命名风格进行命名。
对于这些情况，您可以使用一些帮助程序来查找对象的当前名称样式。
还有一个 setter 方法允许您将值进行更改。
因此在下面的示例中，我们将用 seqlevelStyle() 将 「UCSC」 转换为基于命名规定的 「ensembl」 （然后再次转换）。





```{r}
head(seqlevels(txdb))
seqlevelsStyle(txdb)
seqlevelsStyle(txdb) <- "NCBI"
head(seqlevels(txdb))

## 然后再进行转换
seqlevelsStyle(txdb) <- "UCSC"
head(seqlevels(txdb))
```

除了能够改变 seqinfo 数据对象的命名样式外，
还可以更换「活跃的」染色体，以便软件忽略某些染色体。
默认情况下，所有的染色体都被设置为「活跃的」。


```{r}
head(isActiveSeq(txdb), n=30)
```

但有时你可能希望忽略其中一些染色体。
例如，假设您想要忽略 txdb 数据中的 Y 染色体。你可以这样做:


```{r eval=FALSE}
isActiveSeq(txdb)["chrY"] <- FALSE
head(isActiveSeq(txdb), n=26)
```

## TxDb 练习

练习 5: 访问 **TxDb.Hsapiens.UCSC.hg19** 包能检索所有转录本的基因 ID 、
转录本名称和转录本染色体。使用 select() 和 transcript() 也可以达到目的。输出结果有什么不同?



练习 6: 加载 **TxDb.Athaliana.BioMart.plantsmart22** 包。这个包的数据资源并非取材于 UCSC 数据库，
而是基于 plantsmart 数据库。现在使用 select() 或基于范围的访问函数来查看来自这个 TxDb 对象的基因 ID 。
它们与您在 TxDb.Hsapiens.UCSC.hg19.knownGene 包中看到的内容相比如何？
<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>




# Organism.dplyr 包中 src_organism 对象

如果有来自多个不同 Annotation 对象的数据会发生什么。
例如，如果您在 OrgDb 对象中发现基因符号，
然后您想轻松地将这些符号与基于 UCSC 的 TxDb 对象的已知基因转录本进行匹配，该怎么办？
有一个理想的工具可以帮助解决这类问题，那就是 Organism.dplyr 包中的src_organism 对象。
 src_organism 对象及其相关函数能够为您查询每个 OrgDb 和 TxDb 对象的资源，
然后将结果合并在一起，这样您就可以设想所有注释只有一个来源。



```{r}
library(Organism.dplyr)
```

src_organism 对象可以同时具有 OrgDb 和 TxDb 对象。
使用 supportOrganisms() 函数可以查看 src_organism 对象的有机体组成部分：

```{r}
supported <- supportedOrganisms()
print(supported, n=Inf)
```

请注意单个有机体有多个条目(例如， Homo sapiens 有三个条目)。
每个有机体只有一个 OrgDb 对象，但是可以使用不同的 TxDbs 对象。
我们可以使用 src_organism() 函数创建一个 src_organism 对象，
用以指定所使用的 TxDb 对象的特定版本。
```{r}
library(org.Hs.eg.db)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
```
```{r eval=FALSE}
src <- src_organism("TxDb.Hsapiens.UCSC.hg38.knownGene")
```
```{r echo=FALSE}
src <- src_organism("TxDb.Hsapiens.UCSC.hg38.knownGene", dbpath=tempfile())
```
```{r}
src
```

另一个方法是使用 src_ucsc() 函数来创建。
这将创建一个含有最新可用 TxDb 版本的 src_organism 对象:
```{r eval=FALSE}
src <- src_ucsc("Homo sapiens")
```
```{r}
src
```

对于我们已经讨论过的适用于所有其他 Db 对象的五种方法（ keytypes()、columns()、
keys()、select() 和 mapIds()）也适用于 src_organism 对象。
在这里，我们使用 keytypes() 来显示有哪些 keytype 可以传递给 select() 的 keytype 参数。

```{r}
keytypes(src)
```

使用 columns() 显示哪些 keytypes 可以传递给 select() 的 keytype 参数。

```{r}
columns(src)
```

就是这样。现在您可以像使用 OrgDb 对象或 TxDb 对象一样来使用这些对象。
它的工作原理与它包含的基本对象的工作原理一样:
```{r}
select(src, keys="4488", columns=c("symbol", "tx_name"), keytype="entrez")
```

 Organism.dplyr 包也支持许多提取基因组数据的函数，
允许用户根据 OrgDb 和 TxDb 对象中包含的信息进行筛选。
使用 supportedFIlters() 可以查看 src_organism() 对象支持的筛选函数：
```{r}
head(supportedFilters(src))
```

基于范围的访问函数（如 GenomicFeatures 中的函数）也可以在这里使用。
还有 「_tbl」 函数（例如 transcripts_tbl() ）返回 tbl 对象，而不是 GRanges 对象。
复杂的筛选语句可以作为输入。
在这里，我们使用 GRangesFilter 函数，并使用两个返回不同的类型的访问函数来查询转录本，
这些转录本要么以 「SNORD」 开头，并且位于我们给定的 GRangesFilter 中，要么具有 「ADA」 的符号：


```{r}
gr <- GRangesFilter(GenomicRanges::GRanges("chr1:44000000-55000000"))
transcripts(src, filter=~(symbol %startsWith% "SNORD" & gr) | symbol == "ADA")

transcripts_tbl(src, filter=~(symbol %startsWith% "SNORD" & gr) | symbol == "ADA")
```

## Organism.dplyr 练习

练习 7: 使用 select() 函数查询 src_organic 对象中的基因符号、转录起始和染色体。
然后用 transcripts() 函数做同样的事情。
您可能期望调用 transcripts() 的结果与调用 TxDb 对象的结果看起来一样，但(暂时)不会。


练习 8: 查看在 src_organism 对象上调用 columns() 函数的结果，
并将其与在 org.Hs.eg.db 对象上调用 columns() 的结果进行比较，
然后查看在 TxDb.Hsapiens.UCSC.hg19.knownGene 对象上调用 columns() 的结果。


练习 9: 使用 transcripts() 查询 src_organism 对象中包含字母 「X」 的所有基因符号的 entrez 基因 ID。



<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>


# BSgenome 对象

另一种重要的注释资源类型是 **BSgenome** 包[10]。
存储库中有许多 **BSgenome** 包供您选择。
您还可以使用 available.genomes() 函数来了解其中含有哪些生物体。


```{r}
head(available.genomes())
```

与我们在这里讨论过的其他资源不同，
这些包旨在包含一个生物体特定基因组构建的序列数据。
您可以以常规方式加载这些包之一。
每个对象通常都有一个主对象的别名，该别名比完整包名称短（为方便起见）:


```{r}
ls(2)
Hsapiens
```

 getSeq() 函数是从这些包中提取数据的有用方法。
此函数包含几个参数，但重要的参数是前两个参数。
第一个参数指定所使用的 BSgenome 对象，第二个参数（名称）指定要返回的数据。
例如，如果您调用 getSeq() 并给出一个字符矢量 seqnames 来命名对象，
则您将获得这些染色体的序列，以 DNAStringSet 对象方式存在。


```{r}
seqNms <- seqnames(Hsapiens)
head(seqNms)
getSeq(Hsapiens, seqNms[1:2])
```

但是，如果为第二个参数提供 GRanges 对象，那么您会获取对应于这些范围的 DNAStringSet 数据对象。
这可以是了解特定范围内存在序列的有力方法。
例如，在这里，我们可以提取这样的特定基因的范围，如下。


```{r eval=FALSE}
txby <- transcriptsBy(txdb, by="gene")
geneOfInterest <- txby[["4488"]]
res <- getSeq(Hsapiens, geneOfInterest)
res
```

此外， **Biostrings**[11] 包有许多有用的函数，用于在字符串集等中查找模式。
您可能没有注意到它是什么时候发生的，当您加载了 BSgenome 对象时，
**Biostrings** 包也被加载，所以这些功能已经可供您使用。


## BSgenome 练习

练习 10: 使用您刚刚学到的内容提取基因 PTEN 。


<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>


# biomaRt

另一个伟大的注释资源是 **biomaRt** 包[5,6,7]。 
**biomaRt** 包展现了一系列名为 marts 的不同的在线注释资源。
每个 mart 是一系列在线网络资源中的另一种形式，这些资源遵循允许他们使用此包的约定。因此
这些资源遵循允许他们使用此包的规定。
因此，使用 **biomaRt** 的第一步是仍然加载包，然后决定要使用的 「mart」 。
一旦做出决定，您将使用 useMart() 函数在 R 会话界面中创建一个 mart 对象。 
在这里，我们看看可用的 「marts」 有哪些，然后选择使用最流行的 「marts」 之一: 「ensembl」 mart。



```{r}
head(listMarts())
ensembl <- useMart("ensembl")
ensembl
```

每个 「mart」 可以包含多个不同事物的数据集。因此，下一步是您需要选择数据集。
选择一个数据集后，在调用 useMart() 构造函数时，需要使用 dataset 参数指定该数据集。
在这里，我们将使用人的数据集。


```{r}
head(listDatasets(ensembl))
ensembl <- useMart("ensembl",dataset="hsapiens_gene_ensembl")
ensembl
```

接下来，我们需要考虑属性、值和筛选值（attributes、values 和 filters）。
让我们从属性（ attributes ）开始。 
您可以使用 listAttributes() 函数从 **biomaRt** 包中获取不同类型的属性列表:

```{r}
head(listAttributes(ensembl))
```

使用 getBM() ，您会发现特定属性（ attributes ）有哪些值（ values ）：

```{r}
head(getBM(attributes="chromosome_name", mart=ensembl))
```

**biomaRt** 能返回属性（ attributes ）。
它们与在其他对象上使用 columns() 函数时得到的结果类似。

在 **biomaRt** 包中，筛选值（ filters ）可以与值（ values ）一起使用从而限制或选择返回的内容。
此处的 「values」 视为传递的关键词（ keys ），您希望了解有关这些关键词的详细信息。 
然而，筛选值（ filter ）表示要搜索的关键词的类型。
比如说，您可以设定参数： 特定值（ values ）为 「1」，筛选值（ filter ）为 「chromosome_name」 。
这两个参数值将请求第一条染色体上所匹配的任何属性。
正如这里有属性的列表函数一样，也有一个用于筛选值的列表函数:



```{r}
head(listFilters(ensembl))
```

现在您了解了属性（ attributes ）、值（ values ）和筛选值（ filters ），
您可以调用 getBM() 函数将它们放在一起，并从 mart 中请求相关的特定数据。 
例如，以下请求在苍蝇的 1 号染色体上找到基因符号和 entrez 基因 ID:


```{r}
res <- getBM(attributes=c("hgnc_symbol", "entrezgene"),
                    filters = "chromosome_name",
                    values = "1", mart = ensembl)
head(res)
```

当然您可能已经注意到，有很多关于 getBM() 的参数与您调用 shsapienselect() 时所做的非常相似。
因此，如果它是您的首选项，您现在也可以在 mart 对象上使用标准筛选方法。


```{r}
head(columns(ensembl))
```

## biomaRt 练习

练习 11: 使用 ensembl 中的 「hsapiens_gene_ensembl」 数据集，从人的数据中提取 entrez 基因 ID 为 「1」 的 GO 术语。



练习 12: 现在将您刚刚提取的 GO 术语与 **org.Hs.eg.db** 包中的相同 GO 术语进行比较（可以使用 select() 检索该包）。
您注意到哪些差异？为什么有这些差异?


<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>



# 创建 annotation 对象

现在，您已经意识到 Bioconductor 有很多注释资源。
但是，仍然完全不可能将每个注释资源预先收集在包内以满足所有可能的用途。
因此，几乎所有注释对象都具有特殊的函数，它们可以创建包含通用数据资源或特定文件类型的这些对象（或能加载它们的包）。
下表列出了一些比较热门的对象及函数。



如果您希望结果是这些 | 并且您有这些数据 | 那么您可以调用相关函数
------------------ | ------------------------- | ------------------------------
TxDb            |  tracks from UCSC    |  GenomicFeatures::makeTxDbPackageFromUCSC  
TxDb            |  biomaRt 数据   |  GenomicFeatures::makeTxDbPackageFromBiomaRt  
TxDb            |  gff 或 gtf 文件     |  GenomicFeatures::makeTxDbFromGFF  
OrgDb     |  特定的 data.frames         |  AnnotationForge::makeOrgPackage
OrgDb     |  有效的 Taxonomy ID   |  AnnotationForge::makeOrgPackageFromNCBI
ChipDb    |  org 包 & data.frame |  AnnotationForge::makeChipPackage
BSgenome  |  fasta 或 twobit 序列文件  | BSgenome::forgeBSgenomeDataPkg


在大多数情况下，所安装的注释包将是资源创建函数的输出。

不幸的是，在这里并没有足够的机会来演示如何调用这些函数。 
但实际上，调用这些函数非常简单，此类大多数函数的解释和应用都很好地被记录于相关的手册页和范例中[3，4，10，12]。
像往常一样，您可以在 R 内部看到任何函数的帮助页。




```{r,eval=FALSE}
help("makeTxDbPackageFromUCSC")
```

此类函数往往有很多参数，而且大多数函数也会要求它们的输入数据满足一些特定的条件。
最后，您应该知道，即使在成功创建注释包后，您也必须使用 install.package() 函数
（使用参数 repos = NULL）来安装刚刚创建的任何包源目录。 






# 重要注意事项

 Bioconductor 项目含有来自活跃社区的代码库。
因此，您应该期望本演练中使用的软件会以戏剧化的方式随时间而变化。
例如，本章中描述的 getSeq() 函数预计在未来几个月将进行大刀阔斧的改革。
发生这种情况时，旧函数将在完全发布周期（ 6 个月）内弃用，
然后在被删除之前，在另一个发布周期中将其标记为 defunct 。
此周期已到位，因此可以警告活动用户当前发生的情况以及应在何处查找适当的替代函数。
但显然，如果最终用户不注意软件最新版本的更新，这个系统本身也不会提醒最终用户。
因此，请始终保持您的软件已经更新到最新版本。





紧跟新发展，鼓励用户探索[ bioconductor 网站](http://biotores.org/)，其中包含许多当前的演练和示例。
此外，请访问 [支持站点](https://support.biothe.org/)，您可以在那里提问并参与讨论。





# sessionInfo()

本教程中使用的包版本：

```{r}
sessionInfo()
```


# 致谢

本章中报道的研究得到了国家卫生研究院国家人类基因组研究所的支持，编号为 U41HG004059，
和国家卫生研究院国家癌症研究所，编号为 U24CA180996 。
在这里，我们还要感谢众多产生并维护用于生成并更新此处描述的注释资源的数据的机构。





# 参考文献

1. Wolfgang Huber, Vincent J Carey, Robert Gentleman, Simon Anders, Marc
Carlson, Benilton S Carvalho, Hector Corrada Bravo, Sean Davis,	Laurent Gatto,
Thomas Girke, Raphael Gottardo, Florian Hahne, Kasper D Hansen, Rafael A
Irizarry, Michael Lawrence, Michael I Love, James MacDonald, Valerie Obenchain,
Andrzej K Ole&#347;, Herv&eacute; Pag&egrave;s, Alejandro Reyes, Paul Shannon,
Gordon K Smyth, Dan Tenenbaum, Levi Waldron & Martin Morgan	(2015)
Orchestrating high-throughput genomic analysis with Bioconductor Nature Methods
12:115-121

2. Pages H, Carlson M, Falcon S and Li N. AnnotationDbi: Annotation Database
Interface. R package version 1.30.0.

3. M. Carlson, H. Pages, P. Aboyoun, S. Falcon, M. Morgan, D. Sarkar, M.
Lawrence GenomicFeatures: Tools for making and manipulating transcript centric
annotations version 1.19.38.

4. Lawrence M, Huber W, Pag&egrave;s H, Aboyoun P, Carlson M, Gentleman R,
Morgan M and Carey V (2013). Software for Computing and Annotating Genomic
Ranges. PLoS Computational Biology, 9.
http://dx.doi.org/10.1371/journal.pcbi.1003118,
http://www.ploscompbiol.org/article/info%3Adoi%2F10.1371%2Fjournal.pcbi.1003118

5. Steffen Durinck, Wolfgang Huber biomaRt: Interface to BioMart databases
(e.g. Ensembl, COSMIC ,Wormbase and Gramene) version 2.23.5.

6. Durinck S, Spellman P, Birney E and Huber W (2009). Mapping identifiers for
the integration of genomic datasets with the R/Bioconductor package biomaRt.
Nature Protocols, 4, pp. 1184-1191.

7. Durinck S, Moreau Y, Kasprzyk A, Davis S, De Moor B, Brazma A and Huber W
(2005). BioMart and Bioconductor: a powerful link between biological databases
and microarray data analysis. Bioinformatics, 21, pp. 3439-3440.

8. Morgan M, Carlson M, Tenenbaum D and Arora S. AnnotationHub: Client to
access AnnotationHub resources. R package version 2.0.1.

9. Carlson M, Pages H, Morgan M and Obenchain V. OrganismDbi: Software to
enable the smooth interfacing of different database packages. R package version
1.10.0.

10. Pages H. BSgenome: Infrastructure for Biostrings-based genome data
packages. R package version 1.36.0.

11. Pages H, Aboyoun P, Gentleman R and DebRoy S. Biostrings: String objects
representing biological sequences, and matching algorithms. R package version
2.36.0.

12. Carlson M, and Pages H. AnnotationForge: Code for Building Annotation
Database Packages. R package version 1.10.0.


# 练习解答

## 练习 1:

首先您要做的是在 UCSC 数据库中查找 ah :
```{r}
ahs <- query(ah, "UCSC")
```

然后,你可以寻找与 「hg19」 匹配的基因组值( genome )和与 「hg19」 相匹配的物种 ( species )。
```{r}
ahs <- subset(ahs, ahs$genome=='hg19')
length(ahs)
ahs <- subset(ahs, ahs$species=='Homo sapiens')
length(ahs)
```
您可能会注意到最后两个筛选步骤是多余的(执行其中第一个步骤的 IOW 与执行这两个步骤相同)。 
如果不是这样,我们可能怀疑元数据有问题。



## 练习 2:

这将搜索到 oreganno 注释。
 UCSC 网站上这样描述:"This track displays literature-curated regulatory
regions, transcription factor binding sites, and regulatory
polymorphisms from ORegAnno (Open Regulatory Annotation). For more
detailed information on a particular regulatory element, follow the
link to ORegAnno from the details page."

```{r}
ahs <- query(ah, 'oreganno')
ahs
ahs[1]
oreg <- ahs[['AH5087']]
oreg
```


## 练习 3:

```{r}
keys <- "MSX2"
columns <- c("ENTREZID", "CHR")
select(org.Hs.eg.db, keys, columns, keytype="SYMBOL")
```


## 练习 4:

```{r}
## 首先获得所有的基因符号
orgSymbols <- keys(org.Hs.eg.db, keytype="SYMBOL")
## 其次提取所有与其基因符号匹配的 entrez 基因的 ID
egr <- select(org.Hs.eg.db, keys=orgSymbols, "ENTREZID", "SYMBOL")
length(egr$ENTREZID)
length(unique(egr$ENTREZID))
## 比较:
length(egr$SYMBOL)
length(unique(egr$SYMBOL))
## 让我们选出重复的符号,查看得更仔细...
redund <- egr$SYMBOL
badSymbols <- redund[duplicated(redund)]
select(org.Hs.eg.db, badSymbols, "ENTREZID", "SYMBOL")
```


## 练习 5:

因此,要使用 select() 来检索此信息,您需要操作如下:

```{r}
res1 <- select(TxDb.Hsapiens.UCSC.hg19.knownGene,
               keys(TxDb.Hsapiens.UCSC.hg19.knownGene, keytype="TXID"),
       	       columns=c("GENEID","TXNAME","TXCHROM"), keytype="TXID")

head(res1)
```

使用 transcripts() 检索，您可以这样做:
```{r}
res2 <- transcripts(TxDb.Hsapiens.UCSC.hg19.knownGene,
                    columns = c("gene_id","tx_name"))
head(res2)
```

请注意,在第二种情况下,我们并没有要求染色体信息,
但因为 transcripts() 返回一个 GRanges 对象,因此染色体将自动作为对象的一部分返回。



## 练习 6:

```{r}
res <- transcripts(TxDb.Athaliana.BioMart.plantsmart22, columns = c("gene_id"))
```
您会注意到，此包的基因 ID 是 TAIR 基因座 ID，
并且不像您在 **TxDb.Hsapiens.UCSC.hg19.knownGene** 包中所见到的一样。
请务必一直注意您正查看的 TxDb 对象中正使用的基因 ID 的类型。




## 练习 7:

```{r eval=FALSE}
keys <- keys(Homo.sapiens, keytype="TXID")
res1 <- select(Homo.sapiens,
               keys= keys,
       	       columns=c("SYMBOL","TXSTART","TXCHROM"), keytype="TXID")

head(res1)
```

使用 transcripts() 检索，您可以这样做:
```{r}
res2 <- transcripts(Homo.sapiens, columns="SYMBOL")
head(res2)
```


## 练习 8:

```{r}
columns(Homo.sapiens)
columns(org.Hs.eg.db)
columns(TxDb.Hsapiens.UCSC.hg19.knownGene)
## 您可能还希望这样查看:
transcripts(Homo.sapiens, columns=c("SYMBOL","CHRLOC"))
```
关键区别是， TXSTART 引用 transcript 的开头，源自 **TxDb.Hsapiens.UCSC.hg19.chGene** 包的 TxDb 对象,
尽管 CHRLOC 引用相同内容，但其来自 **org.Hs.eg.db** 中的 OrgDb 对象。
原点很重要，因为 TxDb 对象表示来自 UCSC 的转录组，而 OrgDb 对象主要是来源于 NCBI 的基因中心数据。
结果表明 CHRLOC 的区域不会像 TXSTART 那样多，因为其只记录一个官方基因。
 CHRLOC 数据作为 hg19 的数据被锁定在 org.Hs.eg.db ，但您可以转换不同的 TxDb 对象从而匹配 hg18 等的数据。 
出于这些原因，我们强烈建议使用 TXSTART 而不是 CHRLOC 。 
然而由于历史原因， CHRLOC 仍然保存在 **org** 包中。









## 练习 9:

要查找匹配的关键词，充分利用 pattern 和 column 参数。
```{r}
xk = head(keys(Homo.sapiens, keytype="ENTREZID", pattern="X", column="SYMBOL"))
xk
```
select() 验证结果
```{r}
select(Homo.sapiens, xk, "SYMBOL", "ENTREZID")
```


## 练习 10:

```{r eval=FALSE}
## 按基因分组获取转录本范围
txby <- transcriptsBy(Homo.sapiens, by="gene")
## 查找基因符号 「PTEN」 的 entrez ID  
select(Homo.sapiens, keys='PTEN', columns='ENTREZID', keytype='SYMBOL')
## 提取基因转录本
geneOfInterest <- txby[["5728"]]
## 提取序列
res <- getSeq(Hsapiens, geneOfInterest)
res
```


## 练习 11:

```{r}
ensembl <- useMart("ensembl",dataset="hsapiens_gene_ensembl")
ids=c("1")
getBM(attributes=c('go_id', 'entrezgene'),
		    filters = 'entrezgene',
                    values = ids, mart = ensembl)

```

## 练习 12:

```{r}
ids=c("1")
select(org.Hs.eg.db, keys=ids, columns="GO", keytype="ENTREZID")
```

在编写本练习时，从 **biomaRt** 包返回的 GO 术语数量与从 **org.Hs.eg.db** 包返回的 GO 术语数量不同。
因为两种资源都会更新，所以在将来它们可能会相同。
预计此网络服务（不断更新）将在 **biomaRt** 包中广泛使用但 **org.Hs.eg.db** 包(每年更新两次)并不同步。
这是两个 Bioconductor 包中的一个重要区别，每种方法都有其优缺点。 
持续更新的优点是，您始终拥有最新的注释，对于 GO 术语来说，这些注释通常有所不同。 
使用包的优点是，结果都能被保存在 Bioconductor 的存储库中。这可以帮助您在几年后也能获得与今天相同的答案（可重现性）。








<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>




