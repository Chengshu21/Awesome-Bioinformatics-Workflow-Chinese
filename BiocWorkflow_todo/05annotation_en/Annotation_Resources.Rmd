---
title: Genomic Annotation Resources
author:
- name: Marc RJ Carlson
  affiliation: Fred Hutchinson Cancer Research Center, 1100 Fairview Ave. N., P.O. Box 19024, Seattle, WA, USA 98109-1024
- name: Herve Pages
  affiliation: Fred Hutchinson Cancer Research Center, 1100 Fairview Ave. N., P.O. Box 19024, Seattle, WA, USA 98109-1024
- name: Sonali Arora
  affiliation: Fred Hutchinson Cancer Research Center, 1100 Fairview Ave. N., P.O. Box 19024, Seattle, WA, USA 98109-1024
- name: Valerie Obenchain
  affiliation: Fred Hutchinson Cancer Research Center, 1100 Fairview Ave. N., P.O. Box 19024, Seattle, WA, USA 98109-1024
- name: Martin Morgan
  affiliation: Fred Hutchinson Cancer Research Center, 1100 Fairview Ave. N., P.O. Box 19024, Seattle, WA, USA 98109-1024
  email: maintainer@bioconductor.org
output:
  BiocStyle::html_document
date: 24 April 2018
KeyWords: annotation, next-generation sequencing, R, Bioconductor
vignette: >
  %\VignetteIndexEntry{Genomic Annotation Resources}
  %\VignetteEngine{knitr::rmarkdown}
---

# 版本信息
```{r, echo=FALSE, results="hide", warning=FALSE}
suppressPackageStartupMessages({
library('annotation')
})
```
<p>
**R version**: `r R.version.string`
<br />
**Bioconductor version**: `r BiocManager::version()`
<br />
**Package version**: `r packageVersion("annotation")`
</p>

# 简介

注释资源在 Bioconductor 的项目中占很大比例【1】。
此外，还可使用特定的包来获取一些允许访问的在线资源。
这里将介绍使用得比较多的资源，并提供一些关于如何使用它们的高级示例。



在过去，一般在分析结束时使用 Bioconductor 注释资源进行注释。
进行大量的数据分析之后，都会使用注释信息来解析最重要的分析结果。
由于注释信息使用得越来越多，在分析起始或是中间某个步骤也会应用它们，
从而帮助指导仍在进行中的研究。除此之外，注释的含义也变得不像以前那么明确。  
习惯上认为，注释只是在进行了多次不同的研究（如基因产物的主要作用）之后才建立起来的东西。
但如今，社区用与以往经典注释几近相同的注释方式来解析大型数据集，即将之作为附加比较的参考。 






 Bioconductor 中的注释资源的获取方式也发生了变化。
以往的注释资源几乎都是以独立的注释包的形式存在【2,3,4】。
而在今天，注释包含有大量注释资源。
目前存储库[release repository](http://bioconductor.org/packages/release/BiocViews.html#___AnnotationData)
有 800 多个的注释包。 下表总结了经常使用包访问的部分重要的注释对象的类：




<style>
table, th, td {
    border-collapse: collapse;
}
th, td {
    padding: 5px;
}
th {
    text-align: left;
    background-color: #D0D0D0;
}
</style>

<table width="100%">
  <tr>
    <th> Object Type </th>
    <th> Example Package Name </th>
    <th> Contents </th>
  </tr>
  <tbody>
    <tr>
      <td> TxDb </td>
      <td>
        <a href =
          "http://bioconductor.org/packages/TxDb.Hsapiens.UCSC.hg19.knownGene/">
          <div> TxDb.Hsapiens.UCSC.hg19.knownGene </div>
        </a>
      </td>
      <td> Transcriptome ranges for the known gene track of Homo sapiens,
           e.g., introns, exons, UTR regions. </td>
    </tr>
    <tr>
      <td> OrgDb </td>
      <td>
        <a href = "http://bioconductor.org/packages/org.Hs.eg.db/">
        <div> org.Hs.eg.db </div>
        </a>
      </td>
      <td> Gene-based information for Homo sapiens; useful for mapping between
           gene IDs, Names, Symbols, GO and KEGG identifiers, etc. </td>
    </tr>
    <tr>
      <td> BSgenome </td>
      <td>
        <a href =
        "http://bioconductor.org/packages/BSgenome.Hsapiens.UCSC.hg19/">
        <div> BSgenome.Hsapiens.UCSC.hg19 </div>
        </a>
      </td>
      <td> Full genome sequence for Homo sapiens. </td>
    </tr>
    <tr>
      <td> Organism.dplyr </td>
      <td>
        <a href = "http://bioconductor.org/packages/Organism.dplyr/">
        <div> src_organism </div>
        </a>
      </td>
      <td> Collection of multiple annotations for a common organism
           and genome build. </td>
    </tr>
    <tr>
      <td> AnnotationHub </td>
      <td>
        <a href = "http://bioconductor.org/packages/AnnotationHub/">
        <div> AnnotationHub </div>
        </a>
      </td>
      <td> Provides a convenient interface to annotations from many
           different sources; objects are returned as fully parsed Bioconductor
           data objects or as the name of a file on disk. </td>
    </tr>
  </tbody>
</table>

尽管注释包很受欢迎，但是提供 Web 服务（如 **biomaRt**【5,6,7】 ）的包和 **AnnotationHub**【8】
包仍然撤下了越来越多的注释资源。这两种包都含有大量的注释资源。



由于快速发展，目前很难发现 Bioconductor 的单个文档包含有所有可能的注释，甚至每种注释。
因此，在这里我们将在一定程度上介绍并描述最流行的注释资源，旨在公开访问它们的常见模式。
希望拥有此信息的用户能够对如何查找和使用必需的附加资源进行有根据的猜测。 
主题将涵盖以下内容：






# 安装

本章我们会用到部分 Bioconductor 包。 您可以使用 `BiocManager::install()` 进行安装： 


```{r, eval=FALSE}
if (!"BiocManager" %in% rownames(installed.packages()))
     install.packages("BiocManager")
BiocManager::install(c("AnnotationHub", "Homo.sapiens",
           "Organism.dplyr",
           "TxDb.Hsapiens.UCSC.hg19.knownGene",
           "TxDb.Hsapiens.UCSC.hg38.knownGene",
           "BSgenome.Hsapiens.UCSC.hg19", "biomaRt",
           "TxDb.Athaliana.BioMart.plantsmart22"))
```
已安装包的使用方法将会在使用部分进行详细阐述。



# 使用 AnnotationHub

在注释资源列表中靠前的是相对较新的 **AnnotationHub** 包【8】。
创建 AnnotationHub 对象是为了给最终用户提供一个通过 Bioconductor 能够查找大量不同注释对象的便捷接入点。
在 **AnnotationHub** 包中很容易找到注释资源并且以熟悉的 Bioconductor 数据对象形式呈现给用户。
由于它是最近才添加的， 因此 AnnotationHub 允许访问各种形式的注释（如对象），其中一些注释在几年前还不被视为注释。
用户开始使用 AnnotationHub ，只需要加载包，然后创建一个本地 AnnotationHub 对象，如下所示：






```{r, echo=FALSE}
library(annotation)
ah <- AnnotationHub()
```

```{r, eval=FALSE}
ah <- AnnotationHub()
```

第一次调用 AnnotationHub() 时，它将在系统里创建一个缓存目录，并下载 hubs 当前内容的最新元数据。
此时， 当您下载 hubs 数据对象时，它们也会缓存在本地目录中，然后当您再次请求信息的时候，
这些数据文件能被快速访问。



AnnotationHub 对象的结果显示了您当前可以使用该对象访问的资源数量，
并同时给出最常见的数据类型的高级概述。


```{r}
ah
```

正如您从上述对象中所看到的，有很多不同的可用资源。
因此，通常当您获得 AnnotationHub 对象之后首先要做的就是进行筛选，
从而删除不需要的资源。

幸运的是， AnnotationHub 具有几种用于搜索和筛选的不同类型的元数据。 
键入您的 AnnotationHub 对象的名称，然后通过 「$」 运算符补全命令可以查看对象中不同的类别。
要查看单一类别中的所有可能内容，可以将该值传递给 unique() ，如下所示:



```{r}
unique(ah$dataprovider)
```

标记数据的最有意义的方法之一是根据能够返回给您的R对象类型来标记数据。


```{r}
unique(ah$rdataclass)
```

确定要用于查找感兴趣的数据的哪些类型元数据后,
可以使用子集或查询方法将中心对象的大小减小到更易于管理的大小。
一旦您已经确定用哪些类型的元数据来查找您所感兴趣的数据，
您就能用 subset() 或者 query() 方法缩减 hub 对象的大小，以便于更好的管理对象。
比如说，您选择元数据中只有字符串 「GRanges」 所在的记录。
如您之前所看到的， GRanges 是 AnnotationHub 对象中最流行的格式之一。

```{r}
grs <- query(ah, "GRanges")
grs
```

或者您可以使用提取子集的方式，仅选择特定字段上的匹配项

```{r}
grs <- ah[ah$rdataclass == "GRanges",]

```
 subset() 函数也有这种筛选功能。

```{r}
orgs <- subset(ah, ah$rdataclass == "OrgDb")
orgs
```

实际上如果您需要访问所有元数据，则可以用 mcols() 将其提取为 DataFrame 格式的数据对象，如下所示:


```{r}
meta <- mcols(ah)
```

此外，如果您是 GUI （图形用户界面）的粉丝，则可以使用 dispaly() 方法在浏览器中查看数据，
并将所选行返回为较小的 AnnotationHub 对象，如下所示：


```{r, eval=FALSE}
sah <- display(ah)
```

调用此方法将生成基于 Web 的界面，如下图所示:


<img src="display.png" width="100%">


一旦将 AnnotationHub 对象缩减到合理的大小，并确定要检索哪些字段，
那您只需使用 「[[」 运算符来提取它们。
使用 「[[」 运算符，您就可以按数字索引 (1,2,3) 或 AnnotationHub ID 进行提取。 
如果选择使用前者，只需提取您感兴趣的元素即可。 因此，对于我们的一系列范例，您可能只想用第一个索引，如下所示: 



```{r}
res <- grs[[1]]
head(res, n=3)
```

## AnnotationHub 练习

练习 1: 使用 AnnotationHub 来提取 UCSC 数据库中人的 hg19 基因组数据。在筛选每一步的数据时，
 hub 对象会发生什么情况？


练习 2: 您现在基本上已经将内容缩小到 UCSC 基因组浏览器的 hg19 基因组注释，
让我们获取这些注释之一。查找 oreganno 字段并将其保存到局部变量中。


<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>


# OrgDb 对象

此时您可能有个疑问： OrgDb 对象是关于什么的？ 
OrgDb 对象是注释对象系列中的一个成员，
所有注释对象都通过一组共享的方法表示所隐藏的数据。 
因此，如果您仔细看看下面创建的 dog 对象, 您可以看到它包含 Canis familiaris 数据( taxonomy ID = 9615)。
通过 columns() 函数，您可以更多地了解 dog 对象。


```{r}
dog <- query(orgs, "Canis familiaris")[[1]]
dog
```

```{r}
columns(dog)
```

columns() 函数允许从该对象中调用能检索到的数据类型矢量。 
因此，上述调用结果表示可以从 tetra 对象检索多种不同的数据类型。
 

一个类似的函数是 keytype() ，它将列出所有也可以用作关键词的数据类型。


```{r}
keytypes(dog)
```

大多数情况下，结果列出的大部分内容也能通过 keytypes() 调用返回，
但是由于这两个函数功能并不能保证完全相同，所以我们仍然单独使用这两个方法。


这时您能看到哪些类型的对象可用为关键词，可以调用 keys() 函数来提取给定关键词类型的所有关键词。


```{r}
head(keys(dog, keytype="ENTREZID"))
```

keys() 函数中额外的一些参数对获得特定类型的所有 ID 非常有用。
例如，使用 keys() ，您还可以像这样提取含有 「COX」 的基因符号:



```{r}
keys(dog, keytype="SYMBOL", pattern="COX")
```

或者，如果您确实需要其他的关键词类型（ keytype ），可以使用函数中 column 参数
提取包含字符串 「COX」 的基因符号的 ENTREZ 基因 ID:


```{r}
keys(dog, keytype="ENTREZID", pattern="COX", column="SYMBOL")
```

但通常来说，您会想要提取与特定关键词或一组关键词匹配的其他数据。
这里有两种方法可供您选择使用。其中功能更强大的可能是 select() 。
下面是如何通过查找基因符号，以及 REFSEQ ID 来查找特定的 entrez 基因 ID。


```{r}
select(dog, keys="804478", columns=c("SYMBOL","REFSEQ"), keytype="ENTREZID")
```

调用 select() 将返回一个 data.frame ，该数据框尝试为所需要的列填充相匹配的值。
但是，如果您用 select() 提取具有多对一关系的关键词内容，则可能会导致返回数据对象的扩展内容。
看看当我们为相同的 entrez 基因 ID 提取 GO 术语时会发生什么:



```{r}
select(dog, keys="804478", columns="GO", keytype="ENTREZID")
```

因为有多个 GO 术语与基因 「804478」 相关联，所以在 data.frame 中会有很多行。
如果您查找的几个列与原始关键词具有多对一关系，那么可能会出现问题。
这样做的话，结果不仅会成倍增长，而且会变得非常难用。
更好的策略是在调用 select() 时使用具有选择性的关键词。




有时，您可能想以一种比 select() 返回 data.frame 对象更简单的方式来查找匹配结果。
当您只想为每个关键词查找一种值时，这一点尤其重要。
对于这些情况，我们建议您查看 mapIds() 函数。
让我们看看，使用 mapIds() 来查找与最近 select() 调用结果相同的基本信息时会发生什么情况： 


```{r}
mapIds(dog, keys="804478", column="GO", keytype="ENTREZID")
```

如您所见， mapIds() 允许您简化返回的结果。
默认情况下， mapIds() 只返回每个关键词的第一个匹配元素。
但如果您真的需要调用 mapIds() 时返回所有 GO 术语呢?
那么你可以利用 mapIds() 的 multiVals 参数。
这个参数有多个选项，我们已经看到默认情况下只能返回 「first」 结果。
但你也可以返回一个 「list」 或 「CharacterList」 对象，
或者你可以用 「filter」 筛选或返回 「asNA」 有多个匹配的任何关键词。
您甚至可以自定义规则（作为函数），并将其作为参数传递给 multiVals 参数。
让我们看看返回一个列表时会发生什么:


```{r}
mapIds(dog, keys="804478", column="GO", keytype="ENTREZID", multiVals="list")
```

现在，您知道了如何从 OrgDb 对象中提取信息，
您可能会发现，如果知道一系列其他 AnnotationDb 派生的对象，
使用这五种方法（ keytypes()、 columns()、 keys()、 select() 和 mapIds()）也是非常有帮助的。
例如， ChipDb 对象、 InparanoidDb 对象和 TxDb 对象分别包含微阵列探针、inparanoid 同源信息或转录范围信息的数据。
当然还有更专一的对象，比如 GODb 或 ReactomeDb 对象，
它们提供访问 GO 和 reactome 数据库的权限。
在下一节中，我们将看到这些对象中比较流行的 TxDb 对象。




## OrgDb 练习

练习 3: 使用 help("SYMBOL") 查看帮助页面中不同的 columns 和 keytypes 参数值。
现在利用这个信息和我们刚才描述的来查找基因符号 「MSX2」 的 entrez 基因和其染色体。


练习 4: 在之前的练习中，我们使用基因符号作为关键词。
但在过去，这种取值行为有时是不可取的，因为一些基因符号被用作多个基因的官方符号。
要了解这种情况是否仍然存在，利用 entrez 基因 ID 是唯一分配的这一事实，
并从 org.Hs.eg.db 包中提取所有的基因符号及其相关的 entrez 基因 ID 。
然后检查符号是否冗余。



<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>


# TxDb 对象

如前所述， TxDb 对象可以使用一系列标准方法进行访问:
keytypes()， columns()， keys()， select() 和 mapIds()。
但是，由于这些对象包含有关转录组的信息，它们通常用于比较基于转录组信息的范围和基因组的重要特征【3,4】。
因此，它们也有特地用来提取与重要的转录组特征相对应的范围的专用访问器。



让我们从基于 UCSC ensembl 基因记录果蝇的注释包中加载 TxDb 对象开始。
加载这些文件时的一个常见做法是将长名称缩短为 「txdb」 （只是为了方便）。


```{r}
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
txdb
```

仅通过查看 TxDb 对象，我们就可以了解它包含哪些数据，
数据来自何处，它基于 UCSC 基因组的哪个部分构建的，
以及对象最后一次更新的时间。
 TxDb 对象的常见用途之一是从中提取各种文本数据。
例如，您可以从 TxDb 中提取所有的转录本作为 GRanges 对象，就像这样:


```{r}
txs <- transcripts(txdb)
txs
```

同样，也存在 exons()， cds()， genes() 和 promoters() 等用于提取相关信息的函数。
您选择提取哪一种特性取决于您之后想要获取的信息。
如果您只想要这些数据的文本表示，那么这些基本提取函数都可以使用，
但是本质上来说，这些文本的特性大多是嵌套的。因此，与其提取一个简单的 GRanges 对象，
不如选择提取一个 GRangesList 对象，该对象根据与之相关的基因对转录本进行分组，如下图所示:



```{r}
txby <- transcriptsBy(txdb, by="gene")
txby
```

Just as with the flat extractors, there is a whole family of extractors
available depending on what you want to extract and how you want it grouped.
They include transcriptsBy(), exonsBy(), cdsBy(), intronsByTranscript(),
fiveUTRsByTranscript() and threeUTRsByTranscript().

When dealing with genomic data it is almost inevitable that you will run into
problems with the way that different groups have adopted alternate ways of
naming chromosomes.  This is because almost every major repository has cooked
up their own slightly different way of labeling these important features.

To cope with this, the Seqinfo object was invented and is attached to TxDb
objects as well as the GenomicRanges extracted from these objects.  You can
extract it using the seqinfo() method like this:

```{r}
si <- seqinfo(txdb)
si
```

And since the seqinfo information is also attached to the GRanges objects
produced by the TxDb extractors, you can also call seqinfo on the results of
those methods like this:

```{r}
txby <- transcriptsBy(txdb, by="gene")
si <- seqinfo(txby)
```

The Seqinfo object contains a lot of valuable data about which chromosome
features are present, whether they are circular or linear, and how long each
one is.  It is also something that will be checked against if you try to do an
operation like 'findOverlaps' to compute overlapping ranges etc.  So it's a
valuable way to make sure that the chromosomes and genome are the same for your
annotations as the range that you are comparing them to.  But sometimes you may
have a situation where your annotation object contains data that is comparable
to your data object, but where it is simply named with a different naming
style.  For those cases, there are helpers that you can use to discover what
the current name style is for an object.  And there is also a setter method to
allow you to change the value to something more appropriate.  So in the
following example, we are going to change the seqlevelStyle from 'UCSC' to
'ensembl' based naming convention (and then back again).

```{r}
head(seqlevels(txdb))
seqlevelsStyle(txdb)
seqlevelsStyle(txdb) <- "NCBI"
head(seqlevels(txdb))

## then change it back
seqlevelsStyle(txdb) <- "UCSC"
head(seqlevels(txdb))
```

In addition to being able to change the naming style used for an object with
seqinfo data, you can also toggle which of the chromosomes are 'active' so that
the software will ignore certain chromosomes.  By default, all of the
chromosomes are set to be 'active'.  

```{r}
head(isActiveSeq(txdb), n=30)
```

But sometimes you might wish to ignore some of them. For example, lets suppose
that you wanted to ignore the Y chromosome from our txdb. You could do that
like so:

```{r eval=FALSE}
isActiveSeq(txdb)["chrY"] <- FALSE
head(isActiveSeq(txdb), n=26)
```

## TxDb exercises

Exercise 5: Use the accessors for the TxDb.Hsapiens.UCSC.hg19.knownGene package
to retrieve the gene id, transcript name and transcript chromosome for all the
transcripts.  Do this using both the select() method and also using the
transcripts() method.   What is the difference in the output?

Exercise 6: Load the TxDb.Athaliana.BioMart.plantsmart22 package. This package
is not from UCSC and it is based on plantsmart.  Now use select or one of the
range based accessors to look at the gene ids from this TxDb object.  How do
they compare to what you saw in the TxDb.Hsapiens.UCSC.hg19.knownGene package?

<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>


# Organism.dplyr src_organism Objects

So what happens if you have data from multiple different Annotation objects.
For example, what if you had gene SYMBOLS (found in an OrgDb object) and you
wanted to easily match those up with known gene transcript names from a UCSC
based TxDb object? There is an ideal tool that can help with this kind of
problem and it's called an src_organism object from the Organism.dplyr package.
src_organism objects and their related methods are able to query each of OrgDb
and TxDb resources for you and then merge the results back together in way that
lets you pretend that you only have one source for all your annotations.

```{r}
library(Organism.dplyr)
```

src_organism objects can be created for organisms that have both an OrgDb and a
TxDb.  To see organisms that can have src_organism objects made, use the
function supportOrganisms():
```{r}
supported <- supportedOrganisms()
print(supported, n=Inf)
```

Notice how there are multiple entries for a single organism (e.g. three for
Homo sapiens).  There is only one OrgDb per organism, but different TxDbs can be
used. To specify a certain version of a TxDb to use, we can use the
src_organism() function to create an src_organism object.
```{r}
library(org.Hs.eg.db)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
```
```{r eval=FALSE}
src <- src_organism("TxDb.Hsapiens.UCSC.hg38.knownGene")
```
```{r echo=FALSE}
src <- src_organism("TxDb.Hsapiens.UCSC.hg38.knownGene", dbpath=tempfile())
```
```{r}
src
```

We can also create one using the src_ucsc() function.  This will create an
src_organism object using the most recent TxDb version available:
```{r eval=FALSE}
src <- src_ucsc("Homo sapiens")
```
```{r}
src
```

The five methods that worked for all of the other Db objects that we have
discussed (keytypes(), columns(), keys(), select(), and mapIds()) all work for
src_organism objects.  Here, we use keytypes() to show which keytypes can be
passed to the keytype argument of select().
```{r}
keytypes(src)
```

Use columns() to show which keytypes can be passed to the keytype argument of
select().
```{r}
columns(src)
```

And that's it. You can now use these objects in the same way that you use OrgDb
or TxDb objects. It works the same as the base objects that it contains:
```{r}
select(src, keys="4488", columns=c("symbol", "tx_name"), keytype="entrez")
```

Organism.dplyr also supports numerous Genomic Extractor functions allowing users
to filter based on information contained in the OrgDb and TxDb objects.  To see
the filters supported by a src_organism() object, use supportedFIlters():
```{r}
head(supportedFilters(src))
```

The ranged based accessors such as those in GenomicFeatures will also work.
There are also "_tbl" functions (e.g. transcripts_tbl()) that return tbl
objects instead of GRanges objects.  Complex filter statements can be given as
input.  Here we declare a GRangesFilter and use two different type-returning
accessors to query transcripts that either start with "SNORD" and are within our
given GRangesFilter, or have symbol with symbol "ADA":

```{r}
gr <- GRangesFilter(GenomicRanges::GRanges("chr1:44000000-55000000"))
transcripts(src, filter=~(symbol %startsWith% "SNORD" & gr) | symbol == "ADA")

transcripts_tbl(src, filter=~(symbol %startsWith% "SNORD" & gr) | symbol == "ADA")
```

## Organism.dplyr exercises

Exercise 7: Use the src_organism object to look up the gene symbol, transcript
start and chromosome using select(). Then do the same thing using transcripts.
You might expect that this call to transcripts will look the same as it did for
the TxDb object, but (temporarily) it will not.

Exercise 8: Look at the results from call the columns method on the src_organism
object and compare that to what happens when you call columns on the
org.Hs.eg.db object and then look at a call to columns on the
TxDb.Hsapiens.UCSC.hg19.knownGene object.

Exercise 9: Use the src_organism object with the transcripts method to look up
the entrez gene IDs for all gene symbols that contain the letter 'X'.


<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>


# BSgenome Objects

Another important annotation resource type is a BSgenome package[10].  There
are many BSgenome packages in the repository for you to choose from.  And you
can learn which organisms are already supported by using the
available.genomes() function.

```{r}
head(available.genomes())
```

Unlike the other resources that we have discussed here, these packages are
meant to contain sequence data for a specific genome build of an organism.  You
can load one of these packages in the usual way. And each of them normally has
an alias for the primary object that is shorter than the full package name (as
a convenience):

```{r}
ls(2)
Hsapiens
```

The getSeq method is a useful way of extracting data from these packages. This
method takes several arguments but the important ones are the 1st two.  The 1st
argument specifies the BSgenome object to use and the second argument (names)
specifies what data you want back out.  So for example, if you call it and give
a character vector that names the seqnames for the object then you will get the
sequences from those chromosomes as a DNAStringSet object.

```{r}
seqNms <- seqnames(Hsapiens)
head(seqNms)
getSeq(Hsapiens, seqNms[1:2])
```

Whereas if you give the a GRanges object for the 2nd argument, you can instead
get a DNAStringSet that corresponds to those ranges.  This can be a powerful
way to learn what sequence was present from a particular range.  For example,
here we can extract the range of a specific gene of interest like this.

```{r eval=FALSE}
txby <- transcriptsBy(txdb, by="gene")
geneOfInterest <- txby[["4488"]]
res <- getSeq(Hsapiens, geneOfInterest)
res
```

Additionally, the Biostrings[11] package has many useful functions for finding
a pattern in a string set etc.  You may not have noticed when it happened, but
the Biostrings package was loaded when you loaded the BSgenome object, so these
functions will already be available for you to explore.

## BSgenome exercises

Exercise 10: Use what you have just learned to extract the sequence for the
PTEN gene.

<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>


# biomaRt

Another great annotation resource is the biomaRt package[5,6,7].  The biomaRt
package exposes a huge family of different online annotation resources called
marts.  Each mart is another of a set of online web resources that are
following a convention that allows them to work with this package. So the first
step in using biomaRt is always to load the package and then decide which
"mart" you want to use. Once you have made your decision, you will then  use
the useMart() method to create a mart object in your R session.  Here we are
looking at the marts available and then choosing to use one of the most popular
marts: the "ensembl"" mart.

```{r}
head(listMarts())
ensembl <- useMart("ensembl")
ensembl
```

Each 'mart' can contain datasets for multiple different things. So the next
step is that you need to decide on a dataset.  Once you have chosen one, you
will need to specify that dataset using the dataset argument when you call the
useMart() constructor method. Here we will point to the dataset for humans.

```{r}
head(listDatasets(ensembl))
ensembl <- useMart("ensembl",dataset="hsapiens_gene_ensembl")
ensembl
```

Next we need to think about attributes, values and filters. Lets start with
attributes.  You can get a listing of the different kinds of attributes from
biomaRt buy using the listAttributes method:

```{r}
head(listAttributes(ensembl))
```

And you can see what the values for a particular attribute are by using the getBM method:

```{r}
head(getBM(attributes="chromosome_name", mart=ensembl))
```

Attributes are the things that you can have returned from biomaRt.  They are
analogous to what you get when you use the columns method with other objects.

In the biomaRt package, filters are things that can be used with values to
restrict or choose what comes back. The 'values' here are treated as keys that
you are passing in and which you would like to know more information about.  In
contrast, the filter represents the kind of key that you are searching for. So
for example, you might choose a filter name of "chromosome_name" to go with
specific value of "1".  Together these two argument values would request
whatever attributes matched things on the 1st chromosome.  And just as there
here is an accessor for attributes, there is also an accessor for filters:

```{r}
head(listFilters(ensembl))
```

So now you know about attributes, values and filters, you can call the getBM
method to put it all together and request specific data from the mart.  So for
example, the following requests gene symbols and entrez gene IDs that are found
on chromosome 1 of flies:

```{r}
res <- getBM(attributes=c("hgnc_symbol", "entrezgene"),
                    filters = "chromosome_name",
                    values = "1", mart = ensembl)
head(res)
```

Of course you may have noticed that a lot of the arguments for getBM are very
similar to what you do when you call shsapienselect.  So if it's your
preference you can now also use the standard select methods with mart objects.

```{r}
head(columns(ensembl))
```

## biomaRt exercises

Exercise 11: Pull down GO terms for entrez gene id "1" from human by
using the ensembl "hsapiens_gene_ensembl" dataset.


Exercise 12: Now compare the GO terms you just pulled down to the same
GO terms from the org.Hs.eg.db package (which you can now retrieve
using select()). What differences do you notice? Why do you suspect
that is?

<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>


# Creating annotation objects

By now you are aware that Bioconductor has a lot of annotation resources.  But
it is still completely impossible to have every annotation resource
pre-packaged for every conceivable use.  Because of this, almost all annotation
objects have special functions that can be called to create those objects (or
the packages that load them) from generalized data resources or specific file
types.  Below is a table with a few of the more popular options.

If you want this | And you have this | Then you could call this to help
------------------ | ------------------------- | ------------------------------
TxDb            |  tracks from UCSC    |  GenomicFeatures::makeTxDbPackageFromUCSC  
TxDb            |  data from biomaRt   |  GenomicFeatures::makeTxDbPackageFromBiomaRt  
TxDb            |  gff or gtf file     |  GenomicFeatures::makeTxDbFromGFF  
OrgDb     |  custom data.frames         |  AnnotationForge::makeOrgPackage
OrgDb     |  valid Taxonomy ID   |  AnnotationForge::makeOrgPackageFromNCBI
ChipDb    |  org package & data.frame |  AnnotationForge::makeChipPackage
BSgenome  |  fasta or twobit sequence files  | BSgenome::forgeBSgenomeDataPkg


In most cases the output for resource creation functions will be an annotation
package that you can install.  

And there is unfortunately not enough space to demonstrate how to call each of
these functions here.  But to do so is actually pretty straightforward and most
such functions will be well documented with their associated manual pages and
vignettes[3,4,10,12]. As usual, you can see the help page for any function
right inside of R.

```{r,eval=FALSE}
help("makeTxDbPackageFromUCSC")
```

If you plan to make use of these kinds of functions then you should expect to
consult the associated documentation first. These kinds of functions tend to
have a lot of arguments and most of them also require that their input data
meet some fairly specific criteria.  Finally, you should know that even after
you have succeeded at creating an annotation package, you will also have to
make use of the install.packages() function (with the repos argument=NULL) to
install whatever package source directory has just been created.  


# Important considerations

The bioconductor project represents a very large and active codebase from an
active and engaged community. Because of this, you should expect that the
software described in this walkthrough will change over time and often in
dramatic ways.  As an example, the getSeq function that is described in this
chapter is expected to a big overhaul in the coming months.  When this happens
the older function will be deprecated for a full release cycle (6 months) and
then labeled as defunct for another release cycle before it is removed. This
cycle is in place so that active users can be warned about what is happening
and where they should look for the appropriate replacement functionality. But
obviously, this system cannot warn end users if they have not been vigilant
about updating their software to the latest version. So please take the time to
always update your software to the latest version.

To stay abreast of new developments users are encouraged to
explore the [bioconductor website](http://bioconductor.org/) which contains
many current walkthroughs and vignettes. Also visit the
[support site](https://support.bioconductor.org/) where you can ask questions
and engage in discussions.


# sessionInfo()

Package versions used in this tutorial:

```{r}
sessionInfo()
```


# Acknowledgments

Research reported in this chapter was supported by the National Human Genome
Research Institute of the National Institutes of Health under Award Number
U41HG004059 and by the National Cancer Institute of the National Institutes of
Health under Award Number U24CA180996. We also want to thank the numerous
institutions who produced and maintained the data that is used for generating
and updating the annotation resources described here.


# References

1. Wolfgang Huber, Vincent J Carey, Robert Gentleman, Simon Anders, Marc
Carlson, Benilton S Carvalho, Hector Corrada Bravo, Sean Davis,	Laurent Gatto,
Thomas Girke, Raphael Gottardo, Florian Hahne, Kasper D Hansen, Rafael A
Irizarry, Michael Lawrence, Michael I Love, James MacDonald, Valerie Obenchain,
Andrzej K Ole&#347;, Herv&eacute; Pag&egrave;s, Alejandro Reyes, Paul Shannon,
Gordon K Smyth, Dan Tenenbaum, Levi Waldron & Martin Morgan	(2015)
Orchestrating high-throughput genomic analysis with Bioconductor Nature Methods
12:115-121

2. Pages H, Carlson M, Falcon S and Li N. AnnotationDbi: Annotation Database
Interface. R package version 1.30.0.

3. M. Carlson, H. Pages, P. Aboyoun, S. Falcon, M. Morgan, D. Sarkar, M.
Lawrence GenomicFeatures: Tools for making and manipulating transcript centric
annotations version 1.19.38.

4. Lawrence M, Huber W, Pag&egrave;s H, Aboyoun P, Carlson M, Gentleman R,
Morgan M and Carey V (2013). Software for Computing and Annotating Genomic
Ranges. PLoS Computational Biology, 9.
http://dx.doi.org/10.1371/journal.pcbi.1003118,
http://www.ploscompbiol.org/article/info%3Adoi%2F10.1371%2Fjournal.pcbi.1003118

5. Steffen Durinck, Wolfgang Huber biomaRt: Interface to BioMart databases
(e.g. Ensembl, COSMIC ,Wormbase and Gramene) version 2.23.5.

6. Durinck S, Spellman P, Birney E and Huber W (2009). Mapping identifiers for
the integration of genomic datasets with the R/Bioconductor package biomaRt.
Nature Protocols, 4, pp. 1184-1191.

7. Durinck S, Moreau Y, Kasprzyk A, Davis S, De Moor B, Brazma A and Huber W
(2005). BioMart and Bioconductor: a powerful link between biological databases
and microarray data analysis. Bioinformatics, 21, pp. 3439-3440.

8. Morgan M, Carlson M, Tenenbaum D and Arora S. AnnotationHub: Client to
access AnnotationHub resources. R package version 2.0.1.

9. Carlson M, Pages H, Morgan M and Obenchain V. OrganismDbi: Software to
enable the smooth interfacing of different database packages. R package version
1.10.0.

10. Pages H. BSgenome: Infrastructure for Biostrings-based genome data
packages. R package version 1.36.0.

11. Pages H, Aboyoun P, Gentleman R and DebRoy S. Biostrings: String objects
representing biological sequences, and matching algorithms. R package version
2.36.0.

12. Carlson M, and Pages H. AnnotationForge: Code for Building Annotation
Database Packages. R package version 1.10.0.


# Answers for exercises

## Exercise 1:

The 1st thing you need to do is look for thing from UCSC
```{r}
ahs <- query(ah, "UCSC")
```

Then you can look for Genome values that match 'hg19' and a species that matches 'Homo sapiens'.
```{r}
ahs <- subset(ahs, ahs$genome=='hg19')
length(ahs)
ahs <- subset(ahs, ahs$species=='Homo sapiens')
length(ahs)
```
You might notice that the last two filtering steps are redundant (IOW doing the
1st of them is the same as doing both of them.)  If this were not the case, we
might suspect that there was a problem with the metadata.


## Exercise 2:

This pulls down the oreganno annotations.  Which are described on the
UCSC site thusly: "This track displays literature-curated regulatory
regions, transcription factor binding sites, and regulatory
polymorphisms from ORegAnno (Open Regulatory Annotation). For more
detailed information on a particular regulatory element, follow the
link to ORegAnno from the details page."

```{r}
ahs <- query(ah, 'oreganno')
ahs
ahs[1]
oreg <- ahs[['AH5087']]
oreg
```


## Exercise 3:

```{r}
keys <- "MSX2"
columns <- c("ENTREZID", "CHR")
select(org.Hs.eg.db, keys, columns, keytype="SYMBOL")
```


## Exercise 4:

```{r}
## 1st get all the gene symbols
orgSymbols <- keys(org.Hs.eg.db, keytype="SYMBOL")
## and then use that to get all gene symbols matched to all entrez gene IDs
egr <- select(org.Hs.eg.db, keys=orgSymbols, "ENTREZID", "SYMBOL")
length(egr$ENTREZID)
length(unique(egr$ENTREZID))
## VS:
length(egr$SYMBOL)
length(unique(egr$SYMBOL))
## So lets trap these symbols that are redundant and look more closely...
redund <- egr$SYMBOL
badSymbols <- redund[duplicated(redund)]
select(org.Hs.eg.db, badSymbols, "ENTREZID", "SYMBOL")
```


## Exercise 5:

So to retrieve this information using select you need to do it like this:

```{r}
res1 <- select(TxDb.Hsapiens.UCSC.hg19.knownGene,
               keys(TxDb.Hsapiens.UCSC.hg19.knownGene, keytype="TXID"),
       	       columns=c("GENEID","TXNAME","TXCHROM"), keytype="TXID")

head(res1)
```

And to do it using transcripts you do it like this:
```{r}
res2 <- transcripts(TxDb.Hsapiens.UCSC.hg19.knownGene,
                    columns = c("gene_id","tx_name"))
head(res2)
```

Notice that in the 2nd case we don't have to ask for the chromosome,
as transcripts() returns a GRanges object, so the chromosome will
automatically be returned as part of the object.


## Exercise 6:

```{r}
res <- transcripts(TxDb.Athaliana.BioMart.plantsmart22, columns = c("gene_id"))
```
You will notice that the gene ids for this package are TAIR locus IDs
and are NOT entrez gene IDs like what you saw in the
TxDb.Hsapiens.UCSC.hg19.knownGene package.  It's important to always
pay attention to the kind of gene id is being used by the TxDb
you are looking at.


## Exercise 7:

```{r eval=FALSE}
keys <- keys(Homo.sapiens, keytype="TXID")
res1 <- select(Homo.sapiens,
               keys= keys,
       	       columns=c("SYMBOL","TXSTART","TXCHROM"), keytype="TXID")

head(res1)
```

And to do it using transcripts you do it like this:
```{r}
res2 <- transcripts(Homo.sapiens, columns="SYMBOL")
head(res2)
```


## Exercise 8:

```{r}
columns(Homo.sapiens)
columns(org.Hs.eg.db)
columns(TxDb.Hsapiens.UCSC.hg19.knownGene)
## You might also want to look at this:
transcripts(Homo.sapiens, columns=c("SYMBOL","CHRLOC"))
```
The key difference is that the TXSTART refers to the start of a
transcript and originates in the TxDb object from the
TxDb.Hsapiens.UCSC.hg19.knownGene package, while the CHRLOC refers to
the same thing but originates in the OrgDb object from the
org.Hs.eg.db package.  The point of origin is significant because the
TxDb object represents a transcriptome from UCSC and the OrgDb
is primarily gene centric data that originates at NCBI.  The upshot is
that CHRLOC will not have as many regions represented as TXSTART,
since there has to be an official gene for there to even be a record.
The CHRLOC data is also locked in for org.Hs.eg.db as data for hg19,
whereas you can swap in a different TxDb object to match the
genome you are using to make it hg18 etc.  For these reasons, we
strongly recommend using TXSTART instead of CHRLOC.  Howeverm CHRLOC
still remains in the org packages for historical reasons.


## Exercise 9:

To find the keys that match, make use of the pattern and column arguments.
```{r}
xk = head(keys(Homo.sapiens, keytype="ENTREZID", pattern="X", column="SYMBOL"))
xk
```
select verifies the results
```{r}
select(Homo.sapiens, xk, "SYMBOL", "ENTREZID")
```


## Exercise 10:

```{r eval=FALSE}
## Get the transcript ranges grouped by gene
txby <- transcriptsBy(Homo.sapiens, by="gene")
## look up the entrez ID for the gene symbol 'PTEN'
select(Homo.sapiens, keys='PTEN', columns='ENTREZID', keytype='SYMBOL')
## subset that genes transcripts
geneOfInterest <- txby[["5728"]]
## extract the sequence
res <- getSeq(Hsapiens, geneOfInterest)
res
```


## Exercise 11:

```{r}
ensembl <- useMart("ensembl",dataset="hsapiens_gene_ensembl")
ids=c("1")
getBM(attributes=c('go_id', 'entrezgene'),
		    filters = 'entrezgene',
                    values = ids, mart = ensembl)

```

## Exercise 12:

```{r}
ids=c("1")
select(org.Hs.eg.db, keys=ids, columns="GO", keytype="ENTREZID")
```

When this exercise was written, there was a different number of GO
terms returned from biomaRt than from org.Hs.eg.db.  This may not
always be true in the future though as both of these resources are
updated.  It is expected however that this web service, (which is
updated continuously) will fall in and out of sync with the
org.Hs.eg.db package (which is updated twice a year).  This is an
important difference as each approach has different advantages and
disadvantages.  The advantage to updating continuously is that you
always have the very latest annotations which are frequently different
for something like GO terms.  The advantage to using a package is that
the results are frozen to a release of Bioconductor. And this can help
you to get the same answers that you get today (reproducibility), a
few years from now.

<p class="back_to_top">[ <a href="#top">Back to top</a> ]</p>
